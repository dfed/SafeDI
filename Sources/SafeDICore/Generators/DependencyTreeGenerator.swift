// Distributed under the MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

import Collections

public actor DependencyTreeGenerator {
    // MARK: Initialization

    public init(
        importStatements: [ImportStatement],
        typeDescriptionToFulfillingInstantiableMap: [TypeDescription: Instantiable]
    ) {
        self.importStatements = importStatements
        self.typeDescriptionToFulfillingInstantiableMap = typeDescriptionToFulfillingInstantiableMap
    }

    // MARK: Public

    public func generateCodeTree() async throws -> String {
        let rootScopeGenerators = try rootScopeGenerators

        let dependencyTree = try await withThrowingTaskGroup(
            of: String.self,
            returning: String.self
        ) { taskGroup in
            for rootScopeGenerator in rootScopeGenerators {
                taskGroup.addTask { try await rootScopeGenerator.generateCode() }
            }
            var generatedRoots = [String]()
            for try await generatedRoot in taskGroup {
                generatedRoots.append(generatedRoot)
            }
            return generatedRoots.removingEmpty().sorted().joined(separator: "\n\n")
        }

        let importsWhitespace = imports.isEmpty ? "" : "\n"
        return """
        // This file was generated by the SafeDIGenerateDependencyTree build tool plugin.
        // Any modifications made to this file will be overwritten on subsequent builds.
        // Please refrain from editing this file directly.
        \(importsWhitespace)\(imports)\(importsWhitespace)
        \(dependencyTree.isEmpty ? "// No root @\(InstantiableVisitor.macroName)-decorated types found, or root types already had a `public init()` method." : dependencyTree)
        """
    }

    public func generateDOTTree() async throws -> String {
        let rootScopeGenerators = try rootScopeGenerators

        let dependencyTree = try await withThrowingTaskGroup(
            of: String.self,
            returning: String.self
        ) { taskGroup in
            for rootScopeGenerator in rootScopeGenerators {
                taskGroup.addTask { try await rootScopeGenerator.generateDOT() }
            }
            var generatedRoots = [String]()
            for try await generatedRoot in taskGroup {
                generatedRoots.append(generatedRoot)
            }
            return generatedRoots.removingEmpty().sorted().joined(separator: "\n\n")
        }

        return """
        \(dependencyTree)
        """
    }

    // MARK: - DependencyTreeGeneratorError

    private enum DependencyTreeGeneratorError: Error, CustomStringConvertible {
        case noInstantiableFound(TypeDescription)
        case unfulfillableProperties([UnfulfillableProperty])
        case instantiableHasForwardedProperty(property: Property, instantiableWithForwardedProperty: Instantiable, parent: Instantiable)
        case constantDependencyCycleDetected([TypeDescription])
        case receivedInstantiatorDependencyCycleDetected(property: Property, directParent: TypeDescription, cycle: [TypeDescription])
        case receivedConstantCycleDetected(instantiated: Property, receivedPropertyChain: [Property])

        var description: String {
            switch self {
            case let .noInstantiableFound(typeDescription):
                "No `@\(InstantiableVisitor.macroName)`-decorated type or extension found to fulfill `@\(Dependency.Source.instantiatedRawValue)`-decorated property with type `\(typeDescription.asSource)`"
            case let .unfulfillableProperties(unfulfillableProperties):
                """
                \(unfulfillableProperties.map {
                    """
                    @\(Dependency.Source.receivedRawValue) property `\($0.property.asSource)` is not @\(Dependency.Source.instantiatedRawValue) or @\(Dependency.Source.forwardedRawValue) in chain:\n\t\(([$0.instantiable.concreteInstantiable] + $0.parentStack)
                        .reversed()
                        .map(\.asSource)
                        .joined(separator: " -> "))\($0.suggestedAlternatives.isEmpty ? "" : "\n\nDid you mean one of the following available properties?\n\($0.suggestedAlternatives.map { "\t`\($0.asSource)`" }.joined(separator: "\n"))")
                    """
                }
                .sorted()
                .joined(separator: "\n\n"))
                """
            case let .instantiableHasForwardedProperty(property, instantiable, parent):
                "Property `\(property.asSource)` on \(parent.concreteInstantiable.asSource) has at least one @\(Dependency.Source.forwardedRawValue) property. Property should instead be of type `\(Dependency.instantiatorType)<\(instantiable.concreteInstantiable.asSource)>`."
            case let .constantDependencyCycleDetected(instantiables):
                """
                Dependency cycle detected:
                \t\(instantiables
                    .map(\.asSource)
                    .reversed()
                    .joined(separator: " -> "))
                """
            case let .receivedInstantiatorDependencyCycleDetected(property, directParent, instantiables):
                """
                Dependency cycle detected! @\(Dependency.Source.instantiatedRawValue) `\(property.asSource)` is @\(Dependency.Source.receivedRawValue) in tree created by @\(Dependency.Source.instantiatedRawValue) `\(property.asSource)`. Declare @\(Dependency.Source.receivedRawValue) `\(property.asSource)` on `\(directParent.asSource)` as @\(Dependency.Source.instantiatedRawValue) to fix. Full cycle:
                \t\(instantiables
                    .map(\.asSource)
                    .reversed()
                    .joined(separator: " -> "))
                """
            case let .receivedConstantCycleDetected(instantiated, receivedPropertyChain):
                """
                Dependency received in same chain it is instantiated:
                \t\("@\(Dependency.Source.instantiatedRawValue) \(instantiated.asSource) -> "
                    + receivedPropertyChain
                    .map { "@\(Dependency.Source.receivedRawValue) \($0.asSource)" }
                    .joined(separator: " -> "))
                """
            }
        }

        struct UnfulfillableProperty: Hashable {
            let property: Property
            let instantiable: Instantiable
            let parentStack: [TypeDescription]
            let suggestedAlternatives: [Property]
        }
    }

    // MARK: Private

    private let importStatements: [ImportStatement]
    private let typeDescriptionToFulfillingInstantiableMap: [TypeDescription: Instantiable]
    private var rootScopeGenerators: [ScopeGenerator] {
        get throws {
            let rootScopeGenerators: [ScopeGenerator] = try {
                try validateReachableTypeDescriptions()

                let typeDescriptionToScopeMap = try createTypeDescriptionToScopeMapping()
                try validatePropertiesAreFulfillable(typeDescriptionToScopeMap: typeDescriptionToScopeMap)
                return try rootInstantiables
                    .sorted()
                    .compactMap {
                        try typeDescriptionToScopeMap[$0]?.createScopeGenerator(
                            for: nil,
                            propertyStack: [],
                            erasedToConcreteExistential: false
                        )
                    }
            }()
            return rootScopeGenerators
        }
    }

    private var imports: String {
        importStatements
            .reduce(into: [String: Set<ImportStatement>]()) { partialResult, importStatement in
                var importsForModuleName = partialResult[importStatement.moduleName, default: []]
                importsForModuleName.insert(importStatement)
                partialResult[importStatement.moduleName] = importsForModuleName
            }
            .flatMap {
                if let wholeModuleImport = $0.value.first(where: {
                    $0.kind.isEmpty
                        && $0.type.isEmpty
                }) {
                    [wholeModuleImport]
                } else {
                    Array($0.value)
                }
            }
            .map {
                """
                #if canImport(\($0.moduleName))
                \($0.asSource)
                #endif
                """
            }
            .sorted()
            .joined(separator: "\n")
    }

    /// A collection of `@Instantiable`-decorated types that are at the roots of their respective dependency trees.
    private lazy var rootInstantiables: Set<TypeDescription> = Set(
        typeDescriptionToFulfillingInstantiableMap
            .values
            .filter(\.isRoot)
            .map(\.concreteInstantiable)
    )

    /// A collection of `@Instantiable`-decorated types that are instantiated by at least one other
    /// `@Instantiable`-decorated type or do not explicitly receive dependencies.
    private lazy var reachableTypeDescriptions: Set<TypeDescription> = {
        var reachableTypeDescriptions = Set<TypeDescription>()

        func recordReachableTypeDescription(_ reachableTypeDescription: TypeDescription) {
            guard !reachableTypeDescriptions.contains(reachableTypeDescription) else {
                // We've visited this tree already. Ignore.
                return
            }
            reachableTypeDescriptions.insert(reachableTypeDescription)
            guard let instantiable = typeDescriptionToFulfillingInstantiableMap[reachableTypeDescription] else {
                // We can't find an instantiable for this type.
                // This is bad, but we'll handle this error in `validateReachableTypeDescriptions()`.
                return
            }
            let reachableChildTypeDescriptions = instantiable
                .dependencies
                .filter(\.isInstantiated)
                .map(\.asInstantiatedType)
            for reachableChildTypeDescription in reachableChildTypeDescriptions {
                recordReachableTypeDescription(reachableChildTypeDescription)
            }
        }

        for reachableTypeDescription in rootInstantiables {
            recordReachableTypeDescription(reachableTypeDescription)
        }

        return reachableTypeDescriptions
    }()

    private func createTypeDescriptionToScopeMapping() throws -> [TypeDescription: Scope] {
        // Create the mapping.
        let typeDescriptionToScopeMap: [TypeDescription: Scope] = reachableTypeDescriptions
            .reduce(into: [TypeDescription: Scope]()) { partialResult, typeDescription in
                if let instantiable = typeDescriptionToFulfillingInstantiableMap[typeDescription],
                   partialResult[instantiable.concreteInstantiable] == nil
                {
                    let scope = Scope(instantiable: instantiable)
                    for instantiableType in instantiable.instantiableTypes {
                        partialResult[instantiableType] = scope
                    }
                }
            }

        // Populate the propertiesToGenerate on each scope.
        for scope in Set(typeDescriptionToScopeMap.values) {
            for dependency in scope.instantiable.dependencies {
                switch dependency.source {
                case let .instantiated(_, erasedToConcreteExistential):
                    let instantiatedType = dependency.asInstantiatedType
                    if let instantiable = typeDescriptionToFulfillingInstantiableMap[instantiatedType],
                       let instantiatedScope = typeDescriptionToScopeMap[instantiatedType]
                    {
                        let type = dependency.property.propertyType
                        if type.isConstant {
                            guard instantiable.dependencies.filter(\.isForwarded).isEmpty else {
                                throw DependencyTreeGeneratorError
                                    .instantiableHasForwardedProperty(
                                        property: dependency.property,
                                        instantiableWithForwardedProperty: instantiable,
                                        parent: scope.instantiable
                                    )
                            }
                        }
                        scope.propertiesToGenerate.append(.instantiated(
                            dependency.property,
                            instantiatedScope,
                            erasedToConcreteExistential: erasedToConcreteExistential
                        ))
                    }
                case let .aliased(fulfillingProperty, erasedToConcreteExistential):
                    scope.propertiesToGenerate.append(.aliased(
                        dependency.property,
                        fulfilledBy: fulfillingProperty,
                        erasedToConcreteExistential: erasedToConcreteExistential
                    ))
                case .forwarded, .received:
                    continue
                }
            }
        }
        return typeDescriptionToScopeMap
    }

    private func validatePropertiesAreFulfillable(typeDescriptionToScopeMap: [TypeDescription: Scope]) throws {
        var unfulfillableProperties = Set<DependencyTreeGeneratorError.UnfulfillableProperty>()
        func validatePropertiesAreFulfillable(
            on scope: Scope,
            receivableProperties: Set<Property>,
            property: Property?,
            propertyStack: OrderedSet<Property>,
            root: TypeDescription
        ) throws {
            let createdProperties = Set(
                scope
                    .instantiable
                    .dependencies
                    .filter {
                        switch $0.source {
                        case .instantiated, .forwarded:
                            // The source is being injected into the dependency tree.
                            true
                        case .aliased:
                            // This property is being re-injected into the dependency tree under a new alias.
                            true
                        case .received:
                            false
                        }
                    }
                    .map(\.property)
            )
            if let property {
                func validateNoCycleInReceivedProperties(
                    scope: Scope,
                    receivedPropertyStack: OrderedSet<Property>
                ) throws {
                    for childProperty in scope.receivedProperties {
                        guard childProperty != property else {
                            throw DependencyTreeGeneratorError.receivedConstantCycleDetected(
                                instantiated: property,
                                receivedPropertyChain: receivedPropertyStack + [childProperty]
                            )
                        }
                        guard !receivedPropertyStack.contains(childProperty) else {
                            // We've found a cycle, but it's not our cycle. Bail and let a future loop find this.
                            return
                        }
                        if let receivedPropertyScope = typeDescriptionToScopeMap[childProperty.typeDescription] {
                            var childPropertyStack = receivedPropertyStack
                            childPropertyStack.append(childProperty)
                            try validateNoCycleInReceivedProperties(
                                scope: receivedPropertyScope,
                                receivedPropertyStack: childPropertyStack
                            )
                        }
                    }
                }
                try validateNoCycleInReceivedProperties(
                    scope: scope,
                    receivedPropertyStack: []
                )
            }

            for receivedProperty in scope.receivedProperties {
                let parentContainsProperty = receivableProperties.contains(receivedProperty)
                let propertyIsCreatedAtThisScope = createdProperties.contains(receivedProperty)
                if !parentContainsProperty, !propertyIsCreatedAtThisScope {
                    if property != nil {
                        // This property is in a dependency tree and is unfulfillable. Record the problem.
                        unfulfillableProperties.insert(.init(
                            property: receivedProperty,
                            instantiable: scope.instantiable,
                            parentStack: propertyStack.map(\.typeDescription) + [root],
                            suggestedAlternatives: receivableProperties.filter {
                                receivedProperty.typeDescription.leastQualifiedTypeDescription == $0.typeDescription.leastQualifiedTypeDescription
                                    || receivedProperty.label == $0.label
                            }.sorted()
                        ))
                    }
                }
            }

            // Check children for cycles.
            var childPropertyStack = propertyStack
            if let property {
                childPropertyStack.insert(property, at: 0)
            }
            for dependency in scope.instantiable.dependencies {
                let propertyForDependency = dependency.source.fulfillingProperty ?? dependency.property
                guard let cycleIndex = childPropertyStack.firstIndex(of: propertyForDependency) else {
                    continue
                }
                let typesInCycle = (
                    [propertyForDependency]
                        + childPropertyStack.elements[0...cycleIndex]
                ).map(\.typeDescription)
                if propertyForDependency.propertyType.isConstant {
                    // We can break a constant dependency cycle if there's lazy instantiation in the tree.
                    if !typesInCycle.contains(where: { !$0.propertyType.isConstant }) {
                        throw DependencyTreeGeneratorError.constantDependencyCycleDetected(typesInCycle)
                    }
                } else if dependency.source.isReceived {
                    throw DependencyTreeGeneratorError.receivedInstantiatorDependencyCycleDetected(
                        property: propertyForDependency,
                        directParent: scope.instantiable.concreteInstantiable,
                        cycle: typesInCycle
                    )
                }
            }

            for childPropertyToGenerate in scope.propertiesToGenerate {
                switch childPropertyToGenerate {
                case let .instantiated(childProperty, childScope, _):
                    guard !childPropertyStack.contains(childProperty) else {
                        // There is a cycle in our scope tree. Do not re-enter it.
                        continue
                    }
                    try validatePropertiesAreFulfillable(
                        on: childScope,
                        receivableProperties: receivableProperties
                            .union(scope.properties)
                            .removing(childProperty),
                        property: childProperty,
                        propertyStack: childPropertyStack,
                        root: root
                    )
                case .aliased:
                    break
                }
            }
        }

        for rootScope in rootInstantiables.compactMap({ typeDescriptionToScopeMap[$0] }) {
            try validatePropertiesAreFulfillable(
                on: rootScope,
                receivableProperties: Set(rootScope.properties),
                property: nil,
                propertyStack: [],
                root: rootScope.instantiable.concreteInstantiable
            )
        }

        if !unfulfillableProperties.isEmpty {
            throw DependencyTreeGeneratorError.unfulfillableProperties(Array(unfulfillableProperties))
        }
    }

    private func validateReachableTypeDescriptions() throws {
        for reachableTypeDescription in reachableTypeDescriptions {
            if typeDescriptionToFulfillingInstantiableMap[reachableTypeDescription] == nil {
                throw DependencyTreeGeneratorError.noInstantiableFound(reachableTypeDescription)
            }
        }
    }
}

// MARK: - Dependency

extension Dependency {
    fileprivate var isInstantiated: Bool {
        switch source {
        case .instantiated:
            true
        case .aliased, .forwarded, .received:
            false
        }
    }

    fileprivate var isForwarded: Bool {
        switch source {
        case .forwarded:
            true
        case .aliased, .instantiated, .received:
            false
        }
    }
}

// MARK: - Set

extension Set {
    fileprivate func removing(_ element: Element) -> Self {
        var setWithoutElement = self
        setWithoutElement.remove(element)
        return setWithoutElement
    }
}

// MARK: - TypeDescription

extension TypeDescription {
    fileprivate var leastQualifiedTypeDescription: TypeDescription {
        switch self {
        case let .nested(name, _, generics):
            .simple(name: name, generics: generics)
        case let .any(typeDescription), let .implicitlyUnwrappedOptional(typeDescription), let .optional(typeDescription), let .some(typeDescription):
            typeDescription.leastQualifiedTypeDescription
        case .array, .attributed, .closure, .composition, .dictionary, .metatype, .simple, .tuple, .unknown, .void:
            self
        }
    }
}
