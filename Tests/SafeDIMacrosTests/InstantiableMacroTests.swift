// Distributed under the MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

import MacroTesting
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport
import XCTest

import SafeDICore

#if canImport(SafeDIMacros)
    @testable import SafeDIMacros

    final class InstantiableMacroTests: XCTestCase {
        let testMacros: [String: Macro.Type] = [
            InstantiableVisitor.macroName: InstantiableMacro.self,
            Dependency.Source.instantiatedRawValue: InjectableMacro.self,
            Dependency.Source.receivedRawValue: InjectableMacro.self,
            Dependency.Source.forwardedRawValue: InjectableMacro.self,
        ]

        // MARK: XCTestCase

        override func invokeTest() {
            withMacroTesting(macros: testMacros) {
                super.invokeTest()
            }
        }

        // MARK: Generation tests

        func test_declaration_generatesRequiredInitializerWithoutAnyDependenciesOnStruct() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithoutAnyDependenciesOnClass() {
            assertMacro {
                """
                @Instantiable
                public class ExampleService: Instantiable {
                }
                """
            } expansion: {
                """
                public class ExampleService: Instantiable {

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithoutAnyDependenciesOnActor() {
            assertMacro {
                """
                @Instantiable
                public actor ExampleService: Instantiable {
                }
                """
            } expansion: {
                """
                public actor ExampleService: Instantiable {

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_doesNotGenerateRequiredInitializerWithoutDependenciesIfItAlreadyExists() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init() {}
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init() {}
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithoutAnyDependenciesAndInitializedVariable() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    var initializedVariable = "test"
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    var initializedVariable = "test"

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithoutAnyDependenciesAndVariableWithAccessor() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    var initializedVariable { "test" }
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    var initializedVariable { "test" }

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerEvenWhenPropertyDecoratedWithUnknownMacro() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated @Unknown let instantiatedA: InstantiatedA
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {@Unknown 
                    let instantiatedA: InstantiatedA

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerEvenWhenPropertyDecoratedWithUnknownMacroInIfConfig() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    #if DEBUG
                    @Unknown
                    #endif
                    let instantiatedA: InstantiatedA
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_doesNotGenerateRequiredInitializerWithDependenciesIfItAlreadyExists() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA

                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_doesNotGenerateRequiredInitializerIfItAlreadyExistsWithClosureDependency() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(block closure: @escaping () -> Void) {
                        self.closure = closure
                    }
                    @Forwarded
                    let closure: () -> Void
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init(block closure: @escaping () -> Void) {
                        self.closure = closure
                    }
                    let closure: () -> Void

                    public typealias ForwardedProperties = () -> Void
                }
                """
            }
        }

        func test_declaration_doesNotGenerateRequiredInitializerIfItAlreadyExistsWithSendableClosureDependency() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(closure: @escaping @Sendable () -> Void) {
                        self.closure = closure
                    }
                    @Forwarded
                    let closure: @Sendable () -> Void
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init(closure: @escaping @Sendable () -> Void) {
                        self.closure = closure
                    }
                    let closure: @Sendable () -> Void

                    public typealias ForwardedProperties = @Sendable () -> Void
                }
                """
            }
        }

        func test_declaration_doesNotGenerateRequiredInitializerIfItAlreadyExistsWithTupleWrappedClosureDependency() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(closure: @escaping @Sendable () -> Void) {
                        self.closure = closure
                    }
                    @Forwarded
                    let closure: (() -> Void)
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init(closure: @escaping @Sendable () -> Void) {
                        self.closure = closure
                    }
                    let closure: (() -> Void)

                    public typealias ForwardedProperties = () -> Void
                }
                """
            }
        }

        func test_declaration_doesNotGenerateRequiredInitializerIfItAlreadyExistsWithDefaultArguments() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    let nonInjectedProperty: Int

                    public init(nonInjectedProperty: Int = 5) {
                        self.nonInjectedProperty = nonInjectedProperty
                    }
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let nonInjectedProperty: Int

                    public init(nonInjectedProperty: Int = 5) {
                        self.nonInjectedProperty = nonInjectedProperty
                    }
                }
                """
            }
        }

        func test_declaration_doesNotGenerateRequiredInitializerWithDependenciesSatisfyingInitializerIfItAlreadyExistsWithDefaultArguments() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA

                    let nonInjectedProperty: Int

                    public init(instantiatedA: InstantiatedA, nonInjectedProperty: Int = 5) {
                        self.instantiatedA = instantiatedA
                        self.nonInjectedProperty = nonInjectedProperty
                    }
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    let nonInjectedProperty: Int

                    public init(instantiatedA: InstantiatedA, nonInjectedProperty: Int = 5) {
                        self.instantiatedA = instantiatedA
                        self.nonInjectedProperty = nonInjectedProperty
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithDependencies() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithDependenciesWhenNestedTypesHaveUninitializedProperties() {
            assertMacro {
                """
                @Instantiable
                public final class ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA

                    public enum NestedEnum {
                        // This won't compile but we should still generate an initializer.
                        let uninitializedProperty: Any
                    }
                    public struct NestedStruct {
                        let uninitializedProperty: Any
                    }
                    public actor NestedActor {
                        let uninitializedProperty: Any
                    }
                    public final class NestedClass {
                        let uninitializedProperty: Any
                    }
                }
                """
            } expansion: {
                """
                public final class ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    public enum NestedEnum {
                        // This won't compile but we should still generate an initializer.
                        let uninitializedProperty: Any
                    }
                    public struct NestedStruct {
                        let uninitializedProperty: Any
                    }
                    public actor NestedActor {
                        let uninitializedProperty: Any
                    }
                    public final class NestedClass {
                        let uninitializedProperty: Any
                    }

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithDependenciesWhenPropertyHasInitializerAndNoType() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA

                    let initializedProperty = 5
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    let initializedProperty = 5

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithDependenciesWhenPropertyHasInitializerAndType() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA

                    let initializedProperty: Int = 5
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    let initializedProperty: Int = 5

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithDependenciesWhenPropertyIsOptional() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA

                    var optionalProperty: Int?
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    var optionalProperty: Int?

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithDependenciesWhenPropertyIsStatic() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let instantiatedA: InstantiatedA

                    // This won't compile but we should still generate an initializer.
                    public static let staticProperty: Int
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let instantiatedA: InstantiatedA

                    // This won't compile but we should still generate an initializer.
                    public static let staticProperty: Int

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatedA: InstantiatedA) {
                        self.instantiatedA = instantiatedA
                    }
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWhenDependencyMissingFromInit() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(forwardedA: ForwardedA, receivedA: ReceivedA) {
                        self.forwardedA = forwardedA
                        self.receivedA = receivedA
                        receivedB = ReceivedB()
                    }

                    @Forwarded
                    let forwardedA: ForwardedA
                    @Received
                    let receivedA: ReceivedA
                    @Received
                    let receivedB: ReceivedB
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init(forwardedA: ForwardedA, receivedA: ReceivedA) {
                        self.forwardedA = forwardedA
                        self.receivedA = receivedA
                        receivedB = ReceivedB()
                    }
                    let forwardedA: ForwardedA
                    let receivedA: ReceivedA
                    let receivedB: ReceivedB

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(forwardedA: ForwardedA, receivedA: ReceivedA, receivedB: ReceivedB) {
                        self.forwardedA = forwardedA
                        self.receivedA = receivedA
                        self.receivedB = receivedB
                    }

                    public typealias ForwardedProperties = ForwardedA
                }
                """
            }
        }

        func test_declaration_generatesForwardedPropertiesWhenThereAreMultipleForwardedProperties() {
            assertMacro {
                """
                @Instantiable
                public final class UserService {
                    @Forwarded
                    let userID: String

                    @Forwarded
                    let userName: String
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable-decorated type or extension must declare conformance to `Instantiable`
                   âœï¸ Declare conformance to `Instantiable`
                public final class UserService {
                    @Forwarded
                    let userID: String

                    @Forwarded
                    let userName: String
                }
                """
            } fixes: {
                """
                @Instantiable
                public final class UserService: Instantiable {
                    @Forwarded
                    let userID: String

                    @Forwarded
                    let userName: String
                }
                """
            } expansion: {
                """
                public final class UserService: Instantiable {
                    let userID: String
                    let userName: String

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(userID: String, userName: String) {
                        self.userID = userID
                        self.userName = userName
                    }

                    public typealias ForwardedProperties = (userID: String, userName: String)
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithClosureDependency() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Forwarded
                    let closure: () -> Void
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let closure: () -> Void

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(closure: @escaping () -> Void) {
                        self.closure = closure
                    }

                    public typealias ForwardedProperties = () -> Void
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWithSendableClosureDependency() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Forwarded
                    let closure: @Sendable () -> Void
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    let closure: @Sendable () -> Void

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(closure: @escaping @Sendable () -> Void) {
                        self.closure = closure
                    }

                    public typealias ForwardedProperties = @Sendable () -> Void
                }
                """
            }
        }

        func test_declaration_generatesRequiredInitializerWhenInstantiatorDependencyMissingFromInit() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    private let instantiatableAInstantiator: Instantiator<ReceivedA>
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    private let instantiatableAInstantiator: Instantiator<ReceivedA>

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init(instantiatableAInstantiator: Instantiator<ReceivedA>) {
                        self.instantiatableAInstantiator = instantiatableAInstantiator
                    }
                }
                """
            }
        }

        func test_extension_doesNotThrowErrorWhenMoreThanOneInstantiateMethodForSameBaseTypeWithDifferingGeneric() {
            assertMacro {
                """
                @Instantiable
                extension Container: Instantiable {
                    public static func instantiate() -> Container<String> {
                        .init(value: "")
                    }
                    public static func instantiate() -> Container<Int> {
                        .init(value: 0)
                    }
                }
                """
            } expansion: {
                """
                extension Container: Instantiable {
                    public static func instantiate() -> Container<String> {
                        .init(value: "")
                    }
                    public static func instantiate() -> Container<Int> {
                        .init(value: 0)
                    }
                }
                """
            }
        }

        func test_extension_doesNotThrowErrorWhenFulfillingAdditionalType() {
            assertMacro {
                """
                @Instantiable(fulfillingAdditionalTypes: [SendableContainer<String>.self])
                extension Container: Instantiable {
                    public static func instantiate() -> Container<String> {
                        .init(value: "")
                    }
                }
                """
            } expansion: {
                """
                extension Container: Instantiable {
                    public static func instantiate() -> Container<String> {
                        .init(value: "")
                    }
                }
                """
            }
        }

        // MARK: Error tests

        func test_declaration_throwsErrorWhenOnProtocol() {
            assertMacro {
                """
                @Instantiable
                public protocol ExampleService {}
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable must decorate an extension on a type or a class, struct, or actor declaration
                public protocol ExampleService {}
                """
            }
        }

        func test_declaration_throwsErrorWhenOnEnum() {
            assertMacro {
                """
                @Instantiable
                public enum ExampleService: Instantiable {}
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable must decorate an extension on a type or a class, struct, or actor declaration
                public enum ExampleService: Instantiable {}
                """
            }
        }

        func test_declaration_throwsErrorWhenFulfillingAdditionalTypesIncludesAShortformOptional() {
            assertMacro {
                """
                @Instantiable(fulfillingAdditionalTypes: [AnyObject?.self])
                public final class ExampleService: Instantiable {}
                """
            } diagnostics: {
                """
                @Instantiable(fulfillingAdditionalTypes: [AnyObject?.self])
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ The argument `fulfillingAdditionalTypes` must not include optionals
                public final class ExampleService: Instantiable {}
                """
            }
        }

        func test_declaration_throwsErrorWhenFulfillingAdditionalTypesIncludesALongformOptional() {
            assertMacro {
                """
                @Instantiable(fulfillingAdditionalTypes: [Optional<AnyObject>.self])
                public final class ExampleService: Instantiable {}
                """
            } diagnostics: {
                """
                @Instantiable(fulfillingAdditionalTypes: [Optional<AnyObject>.self])
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ The argument `fulfillingAdditionalTypes` must not include optionals
                public final class ExampleService: Instantiable {}
                """
            }
        }

        func test_declaration_throwsErrorWhenFulfillingAdditionalTypesIsAPropertyReference() {
            assertMacro {
                """
                let fulfillingAdditionalTypes: [Any.Type] = [AnyObject.self]
                @Instantiable(fulfillingAdditionalTypes: fulfillingAdditionalTypes)
                public final class ExampleService: Instantiable {}
                """
            } diagnostics: {
                """
                let fulfillingAdditionalTypes: [Any.Type] = [AnyObject.self]
                @Instantiable(fulfillingAdditionalTypes: fulfillingAdditionalTypes)
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ The argument `fulfillingAdditionalTypes` must be an inlined array
                public final class ExampleService: Instantiable {}
                """
            }
        }

        func test_declaration_throwsErrorWhenFulfillingAdditionalTypesIsAClosure() {
            assertMacro {
                """
                @Instantiable(fulfillingAdditionalTypes: { [AnyObject.self] }())
                public final class ExampleService: Instantiable {}
                """
            } diagnostics: {
                """
                @Instantiable(fulfillingAdditionalTypes: { [AnyObject.self] }())
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ The argument `fulfillingAdditionalTypes` must be an inlined array
                public final class ExampleService: Instantiable {}
                """
            }
        }

        func test_extension_throwsErrorWhenFulfillingAdditionalTypesIsAPropertyReference() {
            assertMacro {
                """
                let fulfillingAdditionalTypes: [Any.Type] = [AnyObject.self]
                @Instantiable(fulfillingAdditionalTypes: fulfillingAdditionalTypes)
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                let fulfillingAdditionalTypes: [Any.Type] = [AnyObject.self]
                @Instantiable(fulfillingAdditionalTypes: fulfillingAdditionalTypes)
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ The argument `fulfillingAdditionalTypes` must be an inlined array
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_throwsErrorWhenFulfillingAdditionalTypesIsAClosure() {
            assertMacro {
                """
                @Instantiable(fulfillingAdditionalTypes: { [AnyObject.self] }())
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable(fulfillingAdditionalTypes: { [AnyObject.self] }())
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ The argument `fulfillingAdditionalTypes` must be an inlined array
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_throwsErrorWhenMoreThanOneInstantiateMethodForSameType() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                    public static func instantiate(user: User) -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable-decorated extension must have a single `instantiate(â€¦)` method that returns `ExampleService`
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                    public static func instantiate(user: User) -> ExampleService { fatalError() }
                }
                """
            }
        }

        // MARK: FixIt tests

        func test_declaration_fixit_addsFixitWhenNoConformancesDeclared() {
            assertMacro {
                """
                @Instantiable
                public final class ExampleService {
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable-decorated type or extension must declare conformance to `Instantiable`
                   âœï¸ Declare conformance to `Instantiable`
                public final class ExampleService {
                }
                """
            } fixes: {
                """
                @Instantiable
                public final class ExampleService: Instantiable {
                }
                """
            } expansion: {
                """
                public final class ExampleService: Instantiable {

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInstantiableConformanceMissing() {
            assertMacro {
                """
                @Instantiable
                public final class ExampleService: CustomStringConvertible {
                    public var description: String { "ExampleService" }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable-decorated type or extension must declare conformance to `Instantiable`
                   âœï¸ Declare conformance to `Instantiable`
                public final class ExampleService: CustomStringConvertible {
                    public var description: String { "ExampleService" }
                }
                """
            } fixes: {
                """
                @Instantiable
                public final class ExampleService: CustomStringConvertible, Instantiable {
                    public var description: String { "ExampleService" }
                }
                """
            } expansion: {
                """
                public final class ExampleService: CustomStringConvertible, Instantiable {
                    public var description: String { "ExampleService" }

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_doesNotAddFixitWhenRetroactiveInstantiableConformanceMissing() {
            assertMacro {
                """
                @Instantiable
                public final class ExampleService: @retroactive Instantiable, @retroactive CustomStringConvertible {
                    public var description: String { "ExampleService" }
                }
                """
            } expansion: {
                """
                public final class ExampleService: @retroactive Instantiable, @retroactive CustomStringConvertible {
                    public var description: String { "ExampleService" }

                    // A generated initializer that has one argument per SafeDI-injected property.
                    // Because this initializer is generated by a Swift Macro, it can not be used by other Swift Macros.
                    // As a result, this initializer can not be used within a #Preview macro closure.
                    // This initializer is generated only because you have not written an appropriate initializer yourself.
                    // Copy/pasting this generated initializer into your code will enable this initializer to be used within other Swift Macros.
                    public init() {
                    }
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenMultipleInjectableMacrosOnTopOfSingleProperty() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Received
                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Received
                    â•°â”€ ğŸ›‘ Dependency can have at most one of @Instantiated, @Received, or @Forwarded attached macro
                       âœï¸ Remove excessive attached macros
                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Received
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableParameterHasInitializer() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA = .init()
                }
                """
            } diagnostics: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    â•°â”€ ğŸ›‘ Dependency must not have hand-written initializer
                       âœï¸ Remove initializer
                    let receivedA: ReceivedA = .init()
                }
                """
            } fixes: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA 
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA 
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableActorIsNotPublicOrOpen() {
            assertMacro {
                """
                @Instantiable
                actor ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â•°â”€ ğŸ›‘ @Instantiable-decorated type must be `public` or `open`
                   âœï¸ Add `public` modifier
                actor ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public actor ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public actor ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableClassIsNotPublicOrOpen() {
            assertMacro {
                """
                @Instantiable
                class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â•°â”€ ğŸ›‘ @Instantiable-decorated type must be `public` or `open`
                   âœï¸ Add `public` modifier
                class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableFinalClassIsNotPublicOrOpen() {
            assertMacro {
                """
                @Instantiable
                final class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â•°â”€ ğŸ›‘ @Instantiable-decorated type must be `public` or `open`
                   âœï¸ Add `public` modifier
                final class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public final class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public final class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableClassIsInternal() {
            assertMacro {
                """
                @Instantiable
                internal class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â•°â”€ ğŸ›‘ @Instantiable-decorated type must be `public` or `open`
                   âœï¸ Add `public` modifier
                internal class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableClassIsFileprivate() {
            assertMacro {
                """
                @Instantiable
                fileprivate class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â•°â”€ ğŸ›‘ @Instantiable-decorated type must be `public` or `open`
                   âœï¸ Add `public` modifier
                fileprivate class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableClassIsPrivate() {
            assertMacro {
                """
                @Instantiable
                private class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â•°â”€ ğŸ›‘ @Instantiable-decorated type must be `public` or `open`
                   âœï¸ Add `public` modifier
                private class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public class ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitWhenInjectableStructIsNotPublicOrOpen() {
            assertMacro {
                """
                @Instantiable
                struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â•°â”€ ğŸ›‘ @Instantiable-decorated type must be `public` or `open`
                   âœï¸ Add `public` modifier
                struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } fixes: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }

                    @Instantiated
                    let receivedA: ReceivedA
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                    public init(receivedA: ReceivedA) {
                        self.receivedA = receivedA
                    }
                    let receivedA: ReceivedA
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitMissingRequiredInitializerWhenPropertyIsMissingInitializerAndThereAreNoDependencies() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    let uninitializedProperty: Int
                }
                """
            } diagnostics: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                                                           â•°â”€ ğŸ›‘ @Instantiable-decorated type with no @Instantiated, @Received, or @Forwarded-decorated properties must have a `public` or `open` initializer that either takes no parameters or has a default value for each parameter.
                                                              âœï¸ Add required initializer
                    let uninitializedProperty: Int
                }
                """
            } fixes: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                public init() {
                // If the following properties were decorated with the @Instantiated, @Received, or @Forwarded macros, had default values, or were written as computed properties, this initializer could have been auto-generated by the @Instantiable macro.
                uninitializedProperty = <#T##assign_uninitializedProperty#>
                }

                    let uninitializedProperty: Int
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                public init() {
                // If the following properties were decorated with the @Instantiated, @Received, or @Forwarded macros, had default values, or were written as computed properties, this initializer could have been auto-generated by the @Instantiable macro.
                uninitializedProperty = <#T##assign_uninitializedProperty#>
                }

                    let uninitializedProperty: Int
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitMissingRequiredInitializerWhenPropertyIsMissingInitializer() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let receivedA: ReceivedA

                    let uninitializedProperty: Int
                }
                """
            } diagnostics: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                                                           â•°â”€ ğŸ›‘ @Instantiable-decorated type must have a `public` or `open` initializer with a parameter for each @Instantiated, @Received, or @Forwarded-decorated property. Parameters in this initializer that do not correspond to a decorated property must have default values.
                                                              âœï¸ Add required initializer
                    @Instantiated
                    let receivedA: ReceivedA

                    let uninitializedProperty: Int
                }
                """
            } fixes: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                public init(receivedA: ReceivedA) {
                self.receivedA = receivedA
                // If the following properties were decorated with the @Instantiated, @Received, or @Forwarded macros, had default values, or were written as computed properties, this initializer could have been auto-generated by the @Instantiable macro.
                uninitializedProperty = <#T##assign_uninitializedProperty#>
                }

                    @Instantiated
                    let receivedA: ReceivedA

                    let uninitializedProperty: Int
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                public init(receivedA: ReceivedA) {
                self.receivedA = receivedA
                // If the following properties were decorated with the @Instantiated, @Received, or @Forwarded macros, had default values, or were written as computed properties, this initializer could have been auto-generated by the @Instantiable macro.
                uninitializedProperty = <#T##assign_uninitializedProperty#>
                }
                    let receivedA: ReceivedA

                    let uninitializedProperty: Int
                }
                """
            }
        }

        func test_declaration_fixit_addsFixitMissingRequiredInitializerWhenMultiplePropertiesAreMissingInitializer() {
            assertMacro {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                    @Instantiated
                    let receivedA: ReceivedA

                    var uninitializedProperty1: Int
                    let uninitializedProperty2: Int, uninitializedProperty3: Int, initializedProperty = "init"
                    let (uninitializedProperty4, uninitializedProperty5): (Int, Int)
                }
                """
            } diagnostics: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                                                           â•°â”€ ğŸ›‘ @Instantiable-decorated type must have a `public` or `open` initializer with a parameter for each @Instantiated, @Received, or @Forwarded-decorated property. Parameters in this initializer that do not correspond to a decorated property must have default values.
                                                              âœï¸ Add required initializer
                    @Instantiated
                    let receivedA: ReceivedA

                    var uninitializedProperty1: Int
                    let uninitializedProperty2: Int, uninitializedProperty3: Int, initializedProperty = "init"
                    let (uninitializedProperty4, uninitializedProperty5): (Int, Int)
                }
                """
            } fixes: {
                """
                @Instantiable
                public struct ExampleService: Instantiable {
                public init(receivedA: ReceivedA) {
                self.receivedA = receivedA
                // If the following properties were decorated with the @Instantiated, @Received, or @Forwarded macros, had default values, or were written as computed properties, this initializer could have been auto-generated by the @Instantiable macro.
                uninitializedProperty1 = <#T##assign_uninitializedProperty1#>
                uninitializedProperty2 = <#T##assign_uninitializedProperty2#>
                uninitializedProperty3 = <#T##assign_uninitializedProperty3#>
                (uninitializedProperty4, uninitializedProperty5) = <#T##assign_(uninitializedProperty4, uninitializedProperty5)#>
                }

                    @Instantiated
                    let receivedA: ReceivedA

                    var uninitializedProperty1: Int
                    let uninitializedProperty2: Int, uninitializedProperty3: Int, initializedProperty = "init"
                    let (uninitializedProperty4, uninitializedProperty5): (Int, Int)
                }
                """
            } expansion: {
                """
                public struct ExampleService: Instantiable {
                public init(receivedA: ReceivedA) {
                self.receivedA = receivedA
                // If the following properties were decorated with the @Instantiated, @Received, or @Forwarded macros, had default values, or were written as computed properties, this initializer could have been auto-generated by the @Instantiable macro.
                uninitializedProperty1 = <#T##assign_uninitializedProperty1#>
                uninitializedProperty2 = <#T##assign_uninitializedProperty2#>
                uninitializedProperty3 = <#T##assign_uninitializedProperty3#>
                (uninitializedProperty4, uninitializedProperty5) = <#T##assign_(uninitializedProperty4, uninitializedProperty5)#>
                }
                    let receivedA: ReceivedA

                    var uninitializedProperty1: Int
                    let uninitializedProperty2: Int, uninitializedProperty3: Int, initializedProperty = "init"
                    let (uninitializedProperty4, uninitializedProperty5): (Int, Int)
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenNoConformancesDeclared() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable-decorated type or extension must declare conformance to `Instantiable`
                   âœï¸ Declare conformance to `Instantiable`
                extension ExampleService {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiableConformanceMissing() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: CustomStringConvertible {
                    public static func instantiate() -> ExampleService { fatalError() }

                    public var description: String { "ExampleService" }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable-decorated type or extension must declare conformance to `Instantiable`
                   âœï¸ Declare conformance to `Instantiable`
                extension ExampleService: CustomStringConvertible {
                    public static func instantiate() -> ExampleService { fatalError() }

                    public var description: String { "ExampleService" }
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: CustomStringConvertible, Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }

                    public var description: String { "ExampleService" }
                }
                """
            } expansion: {
                """
                extension ExampleService: CustomStringConvertible, Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }

                    public var description: String { "ExampleService" }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodMissing() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                                                        â•°â”€ ğŸ›‘ @Instantiable-decorated extension of ExampleService must have a `public static func instantiate() -> ExampleService` method
                                                           âœï¸ Add `public static func instantiate() -> ExampleService` method
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                public static func instantiate() -> ExampleService
                {}


                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                public static func instantiate() -> ExampleService
                {}


                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodIsNotPublic() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    static func instantiate() -> ExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extension must have an `instantiate()` method that is both `public` and `static`
                       âœï¸ Set `public static` modifiers
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodIsNotStatic() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public func instantiate() -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public func instantiate() -> ExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extension must have an `instantiate()` method that is both `public` and `static`
                       âœï¸ Set `public static` modifiers
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodIsNotStaticOrPublic() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    func instantiate() -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    func instantiate() -> ExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extension must have an `instantiate()` method that is both `public` and `static`
                       âœï¸ Set `public static` modifiers
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodReturnsIncorrectType() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> OtherExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> OtherExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extensionâ€™s `instantiate()` method must return the same base type as the extended type
                       âœï¸ Make `instantiate()`â€™s return type the same base type as the extended type
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodReturnsTypeWrappedInArray() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> [ExampleService] { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> [ExampleService] { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extensionâ€™s `instantiate()` method must return the same base type as the extended type
                       âœï¸ Make `instantiate()`â€™s return type the same base type as the extended type
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodIsAsync() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() async -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() async -> ExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extensionâ€™s `instantiate()` method must not throw or be async
                       âœï¸ Remove effect specifiers
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodThrows() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() throws -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() throws -> ExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extensionâ€™s `instantiate()` method must not throw or be async
                       âœï¸ Remove effect specifiers
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodIsAsyncAndThrows() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() async throws -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() async throws -> ExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extensionâ€™s `instantiate()` method must not throw or be async
                       âœï¸ Remove effect specifiers
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodHasGenericParameter() {
            assertMacro {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate<T>() -> ExampleService { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate<T>() -> ExampleService { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extensionâ€™s `instantiate()` method must not have a generic parameter
                       âœï¸ Remove generic parameter
                }
                """
            } fixes: {
                """
                @Instantiable
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            } expansion: {
                """
                extension ExampleService: Instantiable {
                    public static func instantiate() -> ExampleService { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenInstantiateMethodHasGenericWhereClause() {
            assertMacro {
                """
                @Instantiable
                extension Array: Instantiable {
                    public static func instantiate() -> Array where Element == String { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                extension Array: Instantiable {
                    public static func instantiate() -> Array where Element == String { fatalError() }
                    â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    â•°â”€ ğŸ›‘ @Instantiable-decorated extension must not have a generic `where` clause
                       âœï¸ Remove generic `where` clause
                }
                """
            } fixes: {
                """
                @Instantiable
                extension Array: Instantiable {
                    public static func instantiate() -> Array { fatalError() }
                }
                """
            } expansion: {
                """
                extension Array: Instantiable {
                    public static func instantiate() -> Array { fatalError() }
                }
                """
            }
        }

        func test_extension_fixit_addsFixitWhenExtensionHasGenericWhereClause() {
            assertMacro {
                """
                @Instantiable
                extension Array: Instantiable where Element == String {
                    public static func instantiate() -> Array { fatalError() }
                }
                """
            } diagnostics: {
                """
                @Instantiable
                â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â•°â”€ ğŸ›‘ @Instantiable-decorated extension must not have a generic `where` clause
                   âœï¸ Remove generic `where` clause
                extension Array: Instantiable where Element == String {
                    public static func instantiate() -> Array { fatalError() }
                }
                """
            } fixes: {
                """
                @Instantiable
                extension Array: Instantiable {
                    public static func instantiate() -> Array { fatalError() }
                }
                """
            } expansion: {
                """
                extension Array: Instantiable {
                    public static func instantiate() -> Array { fatalError() }
                }
                """
            }
        }
    }
#endif
